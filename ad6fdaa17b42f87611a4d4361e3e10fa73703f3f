{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a9cdd169_3d5fe546",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1017196
      },
      "writtenOn": "2021-10-14T11:11:56Z",
      "side": 1,
      "message": "Is there a hidden way to release the state structure? I think that there is not any because there was yet no need for it.",
      "revId": "ad6fdaa17b42f87611a4d4361e3e10fa73703f3f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c7d1d87c_d2728f29",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-10-14T11:27:12Z",
      "side": 1,
      "message": "struct state itself is on the stack (as part of copytool private, `struct client client` in clients or directly `struct state state` on coordinatool), so never freed for itself.\n\nIts members should be freed if dynamically allocated though and I probably missed some.\nIf you spot some in clients it should be added in common code and hooked before free(ct) in preload/preload.c and before normal exit for client/client.c\n\nFor server the main loop has no normal exit, but it would be useful for debugging memory leaks eventually -- it would make sense to add either a sigterm handler to properly exit or a terminate message from client for that.",
      "parentUuid": "a9cdd169_3d5fe546",
      "revId": "ad6fdaa17b42f87611a4d4361e3e10fa73703f3f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "72a90234_5907a99f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1017196
      },
      "writtenOn": "2021-10-14T11:49:59Z",
      "side": 1,
      "message": "My bad, I wanted to say state structure contents, and I figured that for now, none of its fields needed to be released. But I do not think this is the case for this new hostname field.",
      "parentUuid": "c7d1d87c_d2728f29",
      "revId": "ad6fdaa17b42f87611a4d4361e3e10fa73703f3f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "49170f2d_466cf19d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-10-14T12:01:14Z",
      "side": 1,
      "message": "Yes, but it\u0027s the same really: there\u0027s no way out of the main loop, so no point in freeing things.\n\nThe other char* for the server come straight from argv[i] so don\u0027t actually need to be freed, but we\u0027re actually leaking ctdata, so when a way out of the main loop is added we\u0027ll need to add llapi_hsm_copytool_unregister for it. There\u0027s also the epoll fd to close etc.. quite a bit of cleanup is missing.\n\n\nFor the client I was a bit more careful, there also are char* but I cheated with either passing directly argv[i] or static char config_host[256] / static char config_port[6] or client.active_requests.fsname so they wouldn\u0027t need to be freed. I guess these should be converted to strdup and free if we ever add really dynamic variables, but there has been no need for it for now.",
      "parentUuid": "72a90234_5907a99f",
      "revId": "ad6fdaa17b42f87611a4d4361e3e10fa73703f3f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}